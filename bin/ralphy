#!/bin/bash
# ralphy - Ralphy Wiggum Loop fÃ¼r autonome AI-Entwicklung
#
# UnterstÃ¼tzt OpenCode als CLI-Tool
#
# Usage: ralphy [OPTIONS] [max_iterations]

VERSION="0.1"

set -e

# Global variable for progress PID
PROGRESS_PID=""

# Trap signals to clean up background processes
cleanup() {
    # Reset terminal scroll region first (in case it was modified)
    # printf "\033[r" >&2 2>/dev/null || true       # Reset scroll region
    printf "\033[1;1H\033[K" >&2 2>/dev/null || true  # Clear status line
    printf "\033[999;1H" >&2 2>/dev/null || true  # Move to bottom

    echo ""
    echo "ğŸ›‘ Abbruch empfangen, rÃ¤ume auf..."
    if [[ -n "$PROGRESS_PID" ]] && kill -0 "$PROGRESS_PID" 2>/dev/null; then
        kill "$PROGRESS_PID" 2>/dev/null || true
        wait "$PROGRESS_PID" 2>/dev/null || true
    fi
    exit 130  # Exit code 130 for SIGINT
}
trap cleanup SIGINT SIGTERM

# ============================================================================
# CONFIGURATION
# ============================================================================

# Script directory (where ralphy is installed)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Project directory is current working directory
PROJECT_DIR="$(pwd)"

DEFAULT_ITERATIONS=10
PAUSE_SECONDS=5

# Extend PATH to include common installation directories
export PATH="$HOME/.local/bin:$HOME/.cargo/bin:$HOME/bin:$PATH"

# ============================================================================
# SUBCOMMAND DETECTION (before init check)
# ============================================================================

SUBCOMMAND=""           # "create-prd" or empty
GH_ISSUES_MODE=""       # true if --gh-issues
GH_ISSUE_IDS=""         # "1,3,5" or empty (= all open)
CREATE_PRD_AGENT=""     # Agent for PRD creation (default: build)
SELECTED_AGENT=""       # Agent selected for GH-issue loop execution
HAS_GH_ISSUES=""        # true if prd.json contains gh_issue_number fields

if [[ "${1:-}" == "create-prd" ]]; then
    SUBCOMMAND="create-prd"
    shift

    # Parse create-prd arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --gh-issues)
                GH_ISSUES_MODE=true
                shift
                # Check if next arg is a comma-separated list of numbers
                if [[ $# -gt 0 && "$1" =~ ^[0-9]+(,[0-9]+)*$ ]]; then
                    GH_ISSUE_IDS="$1"
                    shift
                fi
                ;;
            --agent)
                shift
                if [[ $# -gt 0 ]]; then
                    CREATE_PRD_AGENT="$1"
                    shift
                else
                    echo "âŒ FEHLER: --agent benÃ¶tigt einen Agenten-Namen"
                    exit 1
                fi
                ;;
            -h|--help)
                echo "Usage: ralphy create-prd --gh-issues [ISSUE_IDS] [--agent NAME]"
                echo ""
                echo "Erstellt eine .ralphy/prd.json aus GitHub Issues."
                echo ""
                echo "Optionen:"
                echo "  --gh-issues [IDs]  GitHub Issues verwenden (alle offenen oder komma-separierte IDs)"
                echo "  --agent NAME       Agent fÃ¼r PRD-Erstellung (Default: build)"
                echo "  -h, --help         Diese Hilfe anzeigen"
                echo ""
                echo "Beispiele:"
                echo "  ralphy create-prd --gh-issues              # Alle offenen Issues"
                echo "  ralphy create-prd --gh-issues 1,3,5        # Nur Issues #1, #3, #5"
                echo "  ralphy create-prd --gh-issues --agent build # Mit bestimmtem Agent"
                exit 0
                ;;
            *)
                echo "Unbekannte Option fÃ¼r create-prd: $1"
                echo "Nutze 'ralphy create-prd --help' fÃ¼r Hilfe."
                exit 1
                ;;
        esac
    done

    # Validate: --gh-issues is required for now
    if [[ "$GH_ISSUES_MODE" != "true" ]]; then
        echo "âŒ FEHLER: create-prd benÃ¶tigt --gh-issues Flag"
        echo "Nutze 'ralphy create-prd --help' fÃ¼r Hilfe."
        exit 1
    fi

    CREATE_PRD_AGENT="${CREATE_PRD_AGENT:-build}"
fi

# ============================================================================
# INITIALIZATION CHECK
# ============================================================================

# Skip init check if we're creating a PRD (it will create the file)
if [[ "$SUBCOMMAND" != "create-prd" ]] && [[ ! -f "$PROJECT_DIR/.ralphy/prd.json" ]]; then
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘     ğŸ‘‹ Willkommen bei Ralphy Wiggum!                        â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Es sieht so aus, als ob dieses Projekt noch nicht fÃ¼r Ralphy konfiguriert ist."
    echo "Keine '.ralphy/prd.json' gefunden."
    echo ""
    echo "MÃ¶chtest du Ralphy fÃ¼r dieses Projekt initialisieren? (y/N) "
    read -p "" -n 1 -r
    echo ""

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Abbruch. Ralphy benÃ¶tigt eine Konfiguration."
        exit 1
    fi

    echo ""
    echo "ğŸš€ Initialisiere Ralphy..."

    # Create directories
    mkdir -p "$PROJECT_DIR/.ralphy"

    # Copy templates
    TEMPLATE_DIR="$SCRIPT_DIR/../templates"

    if [[ -d "$TEMPLATE_DIR" ]]; then
        echo "Kopiere Templates..."
        cp "$TEMPLATE_DIR/ralphy/prd.json" "$PROJECT_DIR/.ralphy/prd.json"
        cp "$TEMPLATE_DIR/ralphy/progress.txt" "$PROJECT_DIR/.ralphy/progress.txt"
        cp "$TEMPLATE_DIR/ralphy/RALPHY_PROMPT.md" "$PROJECT_DIR/.ralphy/RALPHY_PROMPT.md"
        cp "$TEMPLATE_DIR/ralphy/important-perceptions.md" "$PROJECT_DIR/.ralphy/important-perceptions.md"

        # Only copy CLAUDE.md if it doesn't exist
        if [[ ! -f "$PROJECT_DIR/CLAUDE.md" ]]; then
            cp "$TEMPLATE_DIR/CLAUDE.md" "$PROJECT_DIR/CLAUDE.md"
        else
            echo "âš ï¸  CLAUDE.md existiert bereits, Ã¼berspringe..."
        fi

        echo "âœ… Initialisierung abgeschlossen!"
        echo "Bitte bearbeite '.ralphy/prd.json' und passe es an dein Projekt an."
        echo ""
        exit 0
    else
        echo "âŒ FEHLER: Templates nicht gefunden unter $TEMPLATE_DIR"
        exit 1
    fi
fi

# ============================================================================
# ARGUMENT PARSING
# ============================================================================

MODEL=""          # Model for opencode
VARIANT=""        # Variant for opencode (e.g., low, high)
MAX_ITERATIONS=""
CONTINUE_MODE=""  # Continue from last session
BUGFIX_MODE=""    # Bugfixing mode (uses bugs.json instead of prd.json)
FORCE_TASK=""     # Force start with specific task ID (e.g. gh-10)
USER_MESSAGE=""   # Custom message for selector and implementer
CURRENT_BRANCH="" # Current git branch (detected at startup)

show_help() {
    echo "Ralphy Wiggum Loop - Autonome AI-Entwicklung"
    echo ""
    echo "Usage: ralphy [OPTIONS] [max_iterations]"
    echo "       ralphy create-prd --gh-issues [IDs] [--agent NAME]"
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘ SUBCOMMANDS                                                      â•‘"
    echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
    echo "â•‘ create-prd --gh-issues              Alle offenen Issues â†’ prd.json â•‘"
    echo "â•‘ create-prd --gh-issues 1,3,5        Nur bestimmte Issues           â•‘"
    echo "â•‘ create-prd --gh-issues --agent NAME Bestimmter Agent (Def: build)  â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘ MODUS-AUSWAHL                                                    â•‘"
    echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
    echo "â•‘ --bugs, --bugfix  Bugfixing-Modus (nutzt bugs.json statt prd.json) â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘ OpenCode â€” Default Model: github-copilot/gpt-5.2                â•‘"
    echo "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£"
    echo "â•‘ -m, --model MODEL    Model auswÃ¤hlen (opencode models zeigt alle) â•‘"
    echo "â•‘ --variant VARIANT    Variant setzen (z.B. low, high)             â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Weitere Optionen:"
    echo "  -c, --continue      Letzte Session wiederherstellen (aus progress.txt + git diff)"
    echo "  --task ID           Mit bestimmtem Task starten (z.B. gh-10)"
    echo "  --message TEXT      Custom-Nachricht an Selector & Implementer"
    echo "  -h, --help          Diese Hilfe anzeigen"
    echo "  --list              VerfÃ¼gbare Models anzeigen (opencode models)"
    echo "  -v, --version       Version anzeigen"
    echo ""
    echo "GH-Issues Workflow:"
    echo "  1. ralphy create-prd --gh-issues        # PRD aus GitHub Issues erstellen"
    echo "  2. ralphy 10                             # Loop startet, erkennt GH-Issues automatisch"
    echo "     â†’ Interaktive Agent-Auswahl (z.B. qfixer)"
    echo "     â†’ Agent bearbeitet Issues automatisch"
    echo ""
}

show_providers() {
    echo "VerfÃ¼gbare OpenCode Models:"
    echo ""
    opencode models 2>/dev/null || echo "âŒ opencode nicht gefunden. Installiere: curl -fsSL https://opencode.ai/install | bash"
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        --list)
            show_providers
            exit 0
            ;;
        -v|--version)
            echo "ralphy version $VERSION"
            exit 0
            ;;
        -m|--model)
            shift
            if [[ $# -gt 0 ]]; then
                MODEL="$1"
                shift
            else
                echo "âŒ FEHLER: --model benÃ¶tigt einen Model-Namen"
                echo "VerfÃ¼gbare Models: opencode models"
                exit 1
            fi
            ;;
        --variant)
            shift
            if [[ $# -gt 0 ]]; then
                VARIANT="$1"
                shift
            else
                echo "âŒ FEHLER: --variant benÃ¶tigt einen Wert (z.B. low, high)"
                exit 1
            fi
            ;;
        -c|--continue)
            CONTINUE_MODE=true
            shift
            ;;
        --bugfix)
            BUGFIX_MODE=true
            shift
            ;;
        --task)
            shift
            if [[ $# -gt 0 ]]; then
                FORCE_TASK="$1"
                shift
            else
                echo "âŒ FEHLER: --task benÃ¶tigt eine Task-ID (z.B. gh-10)"
                exit 1
            fi
            ;;
        --message|--msg)
            shift
            if [[ $# -gt 0 ]]; then
                USER_MESSAGE="$1"
                shift
            else
                echo "âŒ FEHLER: --message benÃ¶tigt einen Text"
                exit 1
            fi
            ;;
        # Numeric = iterations
        [0-9]*)
            MAX_ITERATIONS="$1"
            shift
            ;;
        *)
            echo "Unbekannte Option: $1"
            echo "Nutze --help fÃ¼r Hilfe."
            exit 1
            ;;
    esac
done

# Set defaults
MODEL=${MODEL:-"github-copilot/gpt-5.2"}

# Derive provider from model
derive_provider() {
    case "$1" in
        github-copilot/*)   echo "github-copilot" ;;
        google/antigravity-claude-opus*)  echo "agy-opus" ;;
        google/antigravity-claude*)       echo "agy" ;;
        google/antigravity-gemini*)       echo "gemini" ;;
        google/*)           echo "google" ;;
        zai-coding-plan/*)  echo "zai" ;;
        cerebras/*)         echo "cerebras" ;;
        opencode/*)         echo "opencode" ;;
        *)                  echo "custom" ;;
    esac
}
PROVIDER=$(derive_provider "$MODEL")
MAX_ITERATIONS=${MAX_ITERATIONS:-$DEFAULT_ITERATIONS}

# Detect current branch
if git rev-parse --git-dir > /dev/null 2>&1; then
    CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "")
fi

# ============================================================================
# BUGFIX MODE CHECK
# ============================================================================

if [[ "$BUGFIX_MODE" == "true" ]]; then
    # Check if bugs.json exists
    if [[ ! -f "$PROJECT_DIR/.ralphy/bugs.json" ]]; then
        echo ""
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        echo "â•‘     ğŸ› BUGFIX MODE                                        â•‘"
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "âŒ FEHLER: bugs.json nicht gefunden unter $PROJECT_DIR/.ralphy/"
        echo ""
        echo "Bitte erstelle eine bugs.json Datei oder nutze das Template:"
        echo "  cp templates/ralphy/bugs.json .ralphy/bugs.json"
        echo ""
        exit 1
    fi

    # Check if BUGFIX_PROMPT.md exists
    if [[ ! -f "$PROJECT_DIR/.ralphy/BUGFIX_PROMPT.md" ]]; then
        # Copy BUGFIX_PROMPT.md if it doesn't exist
        TEMPLATE_DIR="$SCRIPT_DIR/../templates"
        if [[ -f "$TEMPLATE_DIR/ralphy/BUGFIX_PROMPT.md" ]]; then
            cp "$TEMPLATE_DIR/ralphy/BUGFIX_PROMPT.md" "$PROJECT_DIR/.ralphy/BUGFIX_PROMPT.md"
            echo "âœ… BUGFIX_PROMPT.md kopiert."
        fi
    fi
fi

# Build command based on tool
CMD="${OPENCODE_FULL_PATH:-opencode}"
if [[ -n "$VARIANT" ]]; then
    CMD_ARGS="run -m $MODEL --variant=$VARIANT"
    PROVIDER_DISPLAY="OpenCode: $PROVIDER ($MODEL, variant: $VARIANT)"
else
    CMD_ARGS="run -m $MODEL"
    PROVIDER_DISPLAY="OpenCode: $PROVIDER ($MODEL)"
fi

# ============================================================================
# HEADER
# ============================================================================

# Clear screen for fresh start
# clear

# Record global start time for total elapsed tracking
GLOBAL_START_TIME=$(date +%s)
export GLOBAL_START_TIME

# Display mode-specific header
if [[ "$BUGFIX_MODE" == "true" ]]; then
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘     ğŸ› Bugfixing Mode v$VERSION                                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "ğŸ“ Projekt:     $PROJECT_DIR"
    echo "ğŸ¤– Provider:    $PROVIDER_DISPLAY"
    echo "ğŸ”¢ Iterationen: $MAX_ITERATIONS"
    echo "âš¡ Command:     $CMD $CMD_ARGS \"...\""
    echo ""
    echo "ğŸ“‹ Bugs:        .ralphy/bugs.json"
    echo "ğŸ“ Progress:    .ralphy/progress.txt"
    echo ""
else
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘     ğŸ”„ Ralphy Wiggum Loop v$VERSION                                â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "ğŸ“ Projekt:     $PROJECT_DIR"
    echo "ğŸ¤– Provider:    $PROVIDER_DISPLAY"
    echo "ğŸ”¢ Iterationen: $MAX_ITERATIONS"
    echo "âš¡ Command:     $CMD $CMD_ARGS \"...\""
    echo ""
    echo "ğŸ“‹ PRD:         .ralphy/prd.json"
    echo "ğŸ“ Progress:    .ralphy/progress.txt"
    echo ""
fi

# Check if opencode is installed
OPENCODE_CMD=""
if command -v opencode &> /dev/null; then
    OPENCODE_CMD="opencode"
elif [[ -f "$HOME/.local/bin/opencode" ]]; then
    OPENCODE_CMD="$HOME/.local/bin/opencode"
elif [[ -f "$HOME/.cargo/bin/opencode" ]]; then
    OPENCODE_CMD="$HOME/.cargo/bin/opencode"
elif [[ -f "$HOME/bin/opencode" ]]; then
    OPENCODE_CMD="$HOME/bin/opencode"
else
    echo "âŒ FEHLER: opencode ist nicht installiert oder nicht im PATH!"
    echo "Gefundener PATH: $PATH"
    echo "Installiere mit: curl -fsSL https://opencode.ai/install | bash"
    echo "Oder fÃ¼ge das Installationsverzeichnis zum PATH hinzu."
    exit 1
fi
# Update CMD to use found path (will be used later)
OPENCODE_FULL_PATH="$OPENCODE_CMD"

# ============================================================================
# GH-ISSUES DETECTION & AGENT SELECTION
# ============================================================================

# Check if prd.json contains gh_issue_number fields
if [[ -f "$PROJECT_DIR/.ralphy/prd.json" ]] && [[ "$BUGFIX_MODE" != "true" ]]; then
    HAS_GH_ISSUES=$(python3 -c "
import json, sys
try:
    with open('$PROJECT_DIR/.ralphy/prd.json') as f:
        data = json.load(f)
    items = data.get('items', [])
    has_gh = any(item.get('gh_issue_number') for item in items)
    print('true' if has_gh else 'false')
except:
    print('false')
" 2>/dev/null || echo "false")
fi

if [[ "$HAS_GH_ISSUES" == "true" ]]; then
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘  ğŸ™ GitHub Issues erkannt! Agents auswÃ¤hlen:             â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # Load agents dynamically from opencode (single pipeline, no per-line subprocesses)
    OC_CMD="${OPENCODE_FULL_PATH:-opencode}"
    AGENTS=()

    mapfile -t AGENTS < <(
        $OC_CMD agent list 2>/dev/null \
        | sed 's/\x1b\[[0-9;]*m//g' \
        | grep -oP '^[a-zA-Z][a-zA-Z0-9_-]+(?=\s+\()' \
        | grep -v '^selector$'
    )

    # Fallback if no agents found
    if [[ ${#AGENTS[@]} -eq 0 ]]; then
        AGENTS=("ralphy-fixer" "qfixer" "qfixer-agpl" "qfix-fast" "build" "oneshot")
    fi

    # Reusable arrow-key menu function
    # Usage: select_agent "prompt_text" "default_agent_name"
    # Sets MENU_RESULT to the selected agent name
    select_agent_menu() {
        local prompt_text="$1"
        local default_name="$2"
        local hint_text="${3:-}"

        echo "$prompt_text"
        echo ""

        # Find default index
        local default_idx=0
        for idx in "${!AGENTS[@]}"; do
            if [[ "${AGENTS[$idx]}" == "$default_name" ]]; then
                default_idx=$idx
                break
            fi
        done

        local selected=$default_idx
        while true; do
            for idx in "${!AGENTS[@]}"; do
                if [[ $idx -eq $selected ]]; then
                    local line_label="  â¯ ${AGENTS[$idx]}"
                    if [[ -n "$hint_text" && "${AGENTS[$idx]}" == "$default_name" ]]; then
                        line_label+="  ($hint_text)"
                    fi
                    echo "$line_label"
                else
                    echo "    ${AGENTS[$idx]}"
                fi
            done

            read -s -n1 key
            case "$key" in
                $'\x1b')
                    read -s -n2 -t 0.1 seq || true
                    case "$seq" in
                        '[A') ((selected > 0)) && ((selected--)) || true ;;
                        '[B') ((selected < ${#AGENTS[@]}-1)) && ((selected++)) || true ;;
                    esac
                    ;;
                "") break ;;
            esac

            printf "\033[${#AGENTS[@]}A"
        done

        MENU_RESULT="${AGENTS[$selected]}"
    }

    # â”€â”€ Selector-Agent (hidden) â”€â”€
    # User requested a hidden selector agent with specific capabilities
    SELECTOR_AGENT="selector"
    echo ""
    echo "  âœ… Selector: $SELECTOR_AGENT"
    echo ""

    # â”€â”€ PrimÃ¤r-Agent auswÃ¤hlen â”€â”€
    select_agent_menu \
        "ğŸ”§ PrimÃ¤r-Agent (bearbeitet das Issue):" \
        "ralphy-fixer" \
        "empfohlen fÃ¼r Issue-Fixing"
    SELECTED_AGENT="$MENU_RESULT"
    echo ""
    echo "  âœ… PrimÃ¤r:   $SELECTED_AGENT"
    echo ""

    # â”€â”€ Model auswÃ¤hlen â”€â”€
    # Load models dynamically from opencode
    AVAILABLE_MODELS=()
    mapfile -t AVAILABLE_MODELS < <(
        $OC_CMD models 2>/dev/null \
        | sed 's/\x1b\[[0-9;]*m//g' \
        | grep -oP '^[a-zA-Z][a-zA-Z0-9/_.-]+' \
        | sort
    )

    # Fallback if no models found
    if [[ ${#AVAILABLE_MODELS[@]} -eq 0 ]]; then
        AVAILABLE_MODELS=(
            "github-copilot/gpt-5.2"
            "github-copilot/gemini-3-flash-preview"
            "google/antigravity-gemini-3-pro"
            "google/antigravity-claude-sonnet-4-5"
            "google/antigravity-claude-opus-4-5-thinking"
            "zai-coding-plan/glm-4.7"
            "cerebras/zai-glm-4.7"
        )
    fi

    echo "ğŸ§  Model fÃ¼r $SELECTED_AGENT auswÃ¤hlen:"
    echo ""

    # Pre-select the model matching current MODEL (or default to index 0)
    model_selected=0
    if [[ -n "$MODEL" ]]; then
        for idx in "${!AVAILABLE_MODELS[@]}"; do
            if [[ "${AVAILABLE_MODELS[$idx]}" == "$MODEL" ]]; then
                model_selected=$idx
                break
            fi
        done
    fi

    while true; do
        for idx in "${!AVAILABLE_MODELS[@]}"; do
            if [[ $idx -eq $model_selected ]]; then
                label="  â¯ ${AVAILABLE_MODELS[$idx]}"
                if [[ "${AVAILABLE_MODELS[$idx]}" == "${MODEL:-github-copilot/gpt-5.2}" ]]; then
                    label+="  (current)"
                fi
                echo "$label"
            else
                echo "    ${AVAILABLE_MODELS[$idx]}"
            fi
        done

        read -s -n1 key
        case "$key" in
            $'\x1b')
                read -s -n2 -t 0.1 seq || true
                case "$seq" in
                    '[A') ((model_selected > 0)) && ((model_selected--)) || true ;;
                    '[B') ((model_selected < ${#AVAILABLE_MODELS[@]}-1)) && ((model_selected++)) || true ;;
                esac
                ;;
            "") break ;;
        esac

        printf "\033[${#AVAILABLE_MODELS[@]}A"
    done

    MODEL="${AVAILABLE_MODELS[$model_selected]}"
    echo ""
    echo "  âœ… Model:    $MODEL"
    echo ""

    # Update provider and display after model selection
    PROVIDER=$(derive_provider "$MODEL")
    CMD="${OPENCODE_FULL_PATH:-opencode}"
    CMD_ARGS="run -m $MODEL"
    PROVIDER_DISPLAY="OpenCode: $PROVIDER ($MODEL)"
fi

echo "Starte in 3 Sekunden... (Ctrl+C zum Abbrechen)"
sleep 3

# Clear screen before starting the loop
# clear

cd "$PROJECT_DIR"

# ============================================================================
# RALPHY PROMPT LOADING
# ============================================================================

# Determine which prompt file to use based on mode
if [[ "$BUGFIX_MODE" == "true" ]]; then
    PROMPT_FILE=".ralphy/BUGFIX_PROMPT.md"
else
    PROMPT_FILE=".ralphy/RALPHY_PROMPT.md"
fi

# Load prompt from file or use default if missing (but it should exist due to check above)
if [[ -f "$PROMPT_FILE" ]]; then
    RALPHY_PROMPT_BASE=$(cat "$PROMPT_FILE")
else
    echo "âš ï¸  $PROMPT_FILE nicht gefunden! Nutze Fallback."
    RALPHY_PROMPT_BASE='WICHTIG: Du musst in dieser Session CODE SCHREIBEN UND COMMITTEN.'
fi

# ============================================================================
# BUGFIXING HELPER FUNCTIONS
# ============================================================================

# Function to get next bug from bugs.json (highest priority, status=open)
get_next_bug() {
    local bugs_file="$1"

    # Use python or jq to parse and filter bugs
    if command -v python3 &> /dev/null; then
        python3 -c "
import json
import sys

try:
    with open('$bugs_file', 'r') as f:
        data = json.load(f)

    # Priority order
    priority_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}

    # Filter and sort bugs
    open_bugs = [
        bug for bug in data.get('bugs', [])
        if bug.get('status') == 'open'
    ]

    if not open_bugs:
        print('NONE')
        sys.exit(0)

    # Sort by priority (critical first)
    open_bugs.sort(key=lambda x: (
        priority_order.get(x.get('priority', 'medium'), 99),
        x.get('created', '')
    ))

    # Print next bug info
    next_bug = open_bugs[0]
    print(f\"{next_bug['id']}|{next_bug['title']}|{next_bug['priority']}|{next_bug['description']}\")
except Exception as e:
    print(f'ERROR: {e}')
    sys.exit(1)
"
    elif command -v jq &> /dev/null; then
        # Fallback to jq
        jq -r '.bugs[] | select(.status == "open") | "\(.id)|\(.title)|\(.priority)|\(.description)"' "$bugs_file" 2>/dev/null | head -1
    else
        # Very basic fallback (grep and sed)
        echo "ERROR: No python3 or jq available for bug parsing"
    fi
}

# Function to update bug status to resolved
resolve_bug() {
    local bugs_file="$1"
    local bug_id="$2"

    if command -v python3 &> /dev/null; then
        python3 -c "
import json
from datetime import datetime

try:
    with open('$bugs_file', 'r') as f:
        data = json.load(f)

    # Find and update bug
    for bug in data.get('bugs', []):
        if bug.get('id') == '$bug_id':
            bug['status'] = 'resolved'
            bug['resolved'] = datetime.now().strftime('%Y-%m-%d')
            break

    # Write back
    with open('$bugs_file', 'w') as f:
        json.dump(data, f, indent=2)

    print('OK')
except Exception as e:
    print(f'ERROR: {e}')
"
    else
        echo "ERROR: No python3 available for bug resolution"
    fi
}

# ============================================================================
# CREATE-PRD FROM GITHUB ISSUES
# ============================================================================

create_prd_from_issues() {
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘     ğŸ™ PRD aus GitHub Issues erstellen                    â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # Check prerequisites
    if ! command -v gh &> /dev/null; then
        echo "âŒ FEHLER: gh (GitHub CLI) ist nicht installiert!"
        echo "Installiere mit: https://cli.github.com/"
        exit 1
    fi

    if ! git remote get-url origin &> /dev/null 2>&1; then
        echo "âŒ FEHLER: Kein git remote 'origin' gefunden!"
        exit 1
    fi

    # Parse owner/repo from git remote
    local remote_url
    remote_url=$(git remote get-url origin 2>/dev/null)
    local gh_repo
    # Handle SSH and HTTPS URLs
    gh_repo=$(echo "$remote_url" | sed -E 's#^(https?://github\.com/|git@github\.com:)##; s#\.git$##')

    echo "ğŸ“¦ Repository: $gh_repo"
    echo "ğŸ¤– Agent: $CREATE_PRD_AGENT"
    echo ""

    # Fetch issues
    local issues_json=""
    if [[ -n "$GH_ISSUE_IDS" ]]; then
        echo "ğŸ“‹ Lade Issues: #${GH_ISSUE_IDS//,/, #}..."
        local issue_array="["
        local first=true
        IFS=',' read -ra ISSUE_NUMS <<< "$GH_ISSUE_IDS"
        for num in "${ISSUE_NUMS[@]}"; do
            local issue_data
            issue_data=$(gh issue view "$num" --repo "$gh_repo" --json number,title,body,labels 2>/dev/null)
            if [[ $? -ne 0 || -z "$issue_data" ]]; then
                echo "âš ï¸  Issue #$num nicht gefunden oder Fehler beim Laden, Ã¼berspringe..."
                continue
            fi
            if [[ "$first" == "true" ]]; then
                first=false
            else
                issue_array+=","
            fi
            issue_array+="$issue_data"
        done
        issue_array+="]"
        issues_json="$issue_array"
    else
        echo "ğŸ“‹ Lade alle offenen Issues..."
        issues_json=$(gh issue list --repo "$gh_repo" --state open --json number,title,body,labels --limit 100 2>/dev/null)
        if [[ $? -ne 0 || -z "$issues_json" || "$issues_json" == "[]" ]]; then
            echo "âŒ FEHLER: Keine offenen Issues gefunden oder Fehler beim Laden!"
            exit 1
        fi
    fi

    local issue_count
    issue_count=$(echo "$issues_json" | python3 -c "import json,sys; print(len(json.load(sys.stdin)))" 2>/dev/null || echo "0")
    echo "âœ… $issue_count Issues geladen."
    echo ""

    if [[ "$issue_count" == "0" ]]; then
        echo "âŒ Keine Issues zum Verarbeiten gefunden."
        exit 1
    fi

    # Check if prd.json already exists
    mkdir -p "$PROJECT_DIR/.ralphy"
    if [[ -f "$PROJECT_DIR/.ralphy/prd.json" ]]; then
        echo "âš ï¸  .ralphy/prd.json existiert bereits."
        read -p "Ãœberschreiben? (y/N) " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Abbruch."
            exit 0
        fi
    fi

    # Build prompt for the agent
    local prd_prompt
    prd_prompt="Erstelle eine .ralphy/prd.json Datei aus den folgenden GitHub Issues.

## GitHub Issues (JSON):
$issues_json

## GewÃ¼nschtes prd.json Schema:
Die Datei soll unter .ralphy/prd.json geschrieben werden. Format:
{
  \"project_name\": \"$(basename "$PROJECT_DIR")\",
  \"version\": \"1.0\",
  \"items\": [
    {
      \"id\": \"GH-042\",
      \"gh_issue_number\": 42,
      \"category\": \"feature|bugfix|enhancement|refactor\",
      \"priority\": \"critical|high|medium|low\",
      \"description\": \"Issue-Titel\",
      \"details\": \"Issue-Body (bereinigt)\",
      \"verification_steps\": [\"Schritt 1\", \"Schritt 2\"],
      \"files_to_create\": [],
      \"files_to_modify\": [],
      \"dependencies\": [],
      \"passes\": false
    }
  ]
}

## Regeln:
- Item-IDs als GH-<number> formatieren (z.B. GH-042 fÃ¼r Issue #42), mit fÃ¼hrenden Nullen auf 3 Stellen
- gh_issue_number enthÃ¤lt die originale GitHub Issue-Nummer als Integer
- Label-Mapping fÃ¼r PrioritÃ¤ten: 'bug'â†’high, 'critical'/'urgent'â†’critical, 'enhancement'/'feature'â†’medium, Restâ†’medium
- Label-Mapping fÃ¼r Kategorien: 'bug'â†’bugfix, 'enhancement'/'feature'â†’feature, 'refactor'â†’refactor
- Dependencies aus Issue-Referenzen erkennen (#N Verweise im Body)
- Sinnvolle verification_steps aus dem Issue-Kontext ableiten
- passes ist immer false (noch nicht implementiert)
- Schreibe die Datei direkt nach .ralphy/prd.json"

    echo "ğŸš€ Starte Agent '$CREATE_PRD_AGENT' zur PRD-Erstellung..."
    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Find opencode
    local oc_cmd="opencode"
    if [[ -f "$HOME/.local/bin/opencode" ]]; then
        oc_cmd="$HOME/.local/bin/opencode"
    elif [[ -f "$HOME/.cargo/bin/opencode" ]]; then
        oc_cmd="$HOME/.cargo/bin/opencode"
    fi

    # Write prompt to temp file to avoid quoting issues
    local prompt_file
    prompt_file=$(mktemp)
    echo "$prd_prompt" > "$prompt_file"

    # Execute agent
    if command -v expect >/dev/null 2>&1; then
        expect << EXPECT_EOF 2>&1 || true
set timeout 300
set prompt_content [read [open "$prompt_file" r]]
spawn $oc_cmd run --agent $CREATE_PRD_AGENT \$prompt_content
expect {
    -re "Permission required.*Allow once" {
        send "\\r"
        exp_continue
    }
    -re "â¯|\\? " {
        send "\\r"
        exp_continue
    }
    eof {
        catch wait result
        exit [lindex \$result 3]
    }
}
EXPECT_EOF
    else
        $oc_cmd run --agent "$CREATE_PRD_AGENT" "$(cat "$prompt_file")" 2>&1 || true
    fi

    rm -f "$prompt_file" 2>/dev/null || true

    echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Verify result
    if [[ -f "$PROJECT_DIR/.ralphy/prd.json" ]]; then
        local item_count
        item_count=$(python3 -c "
import json, sys
try:
    with open('$PROJECT_DIR/.ralphy/prd.json') as f:
        data = json.load(f)
    print(len(data.get('items', [])))
except:
    print('0')
" 2>/dev/null || echo "0")

        echo ""
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        echo "â•‘  âœ… prd.json erstellt mit $item_count Items aus GitHub Issues     â•‘"
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "NÃ¤chster Schritt: ralphy [ITERATIONS] um die Items abzuarbeiten"
    else
        echo ""
        echo "âŒ FEHLER: .ralphy/prd.json wurde nicht erstellt!"
        echo "Der Agent konnte die Datei nicht schreiben."
        exit 1
    fi
}

# Execute create-prd subcommand if active
if [[ "$SUBCOMMAND" == "create-prd" ]]; then
    create_prd_from_issues
    exit 0
fi

# ============================================================================
# MAIN LOOP
# ============================================================================

# Determine which prompt file to use based on mode
if [[ "$BUGFIX_MODE" == "true" ]]; then
    PROMPT_FILE=".ralphy/BUGFIX_PROMPT.md"
else
    PROMPT_FILE=".ralphy/RALPHY_PROMPT.md"
fi

# Load prompt from file or use default if missing (but it should exist due to check above)
if [[ -f "$PROMPT_FILE" ]]; then
    RALPHY_PROMPT_BASE=$(cat "$PROMPT_FILE")
else
    echo "âš ï¸  $PROMPT_FILE nicht gefunden! Nutze Fallback."
    RALPHY_PROMPT_BASE='WICHTIG: Du musst in dieser Session CODE SCHREIBEN und COMMITTEN.'
fi

# ============================================================================
# MAIN LOOP
# ============================================================================

PERCEPTIONS_FILE="$PROJECT_DIR/.ralphy/important-perceptions.md"
PROGRESS_FILE="$PROJECT_DIR/.ralphy/progress.txt"
CLAUDE_FILE="$PROJECT_DIR/CLAUDE.md"

# Set task file based on mode
if [[ "$BUGFIX_MODE" == "true" ]]; then
    TASK_FILE="$PROJECT_DIR/.ralphy/bugs.json"
    TASK_NAME="Bugs"
else
    TASK_FILE="$PROJECT_DIR/.ralphy/prd.json"
    TASK_NAME="PRD"
fi

# ============================================================================
# CONTINUE MODE LOGIC
# ============================================================================

CONTINUE_CONTEXT=""
if [[ "$CONTINUE_MODE" == "true" ]]; then
    echo ""
    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
    echo "â•‘     ğŸ”„ CONTINUE MODE - Letzte Session wiederherstellen          â•‘"
    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    # Read last line from progress.txt
    if [[ -f "$PROGRESS_FILE" ]]; then
        LAST_ENTRY=$(tail -n 1 "$PROGRESS_FILE" 2>/dev/null || echo "")
        if [[ -n "$LAST_ENTRY" ]]; then
            echo "ğŸ“‹ Letzte Eintrag aus progress.txt:"
            echo "$LAST_ENTRY"
            echo ""

            # Extract item info from the last entry
            # Format: [YYYY-MM-DD HH:MM:SS] ITEM-ID: Title - Description
            LAST_ITEM_ID=$(echo "$LAST_ENTRY" | grep -oP '\[\K[^\]]+' | head -1 | grep -oP 'ITEM-ID: \K[0-9.]+' || echo "")

            # Get git diff to see what was changed
            if git rev-parse --git-dir > /dev/null 2>&1; then
                echo "ğŸ” Git Diff (nicht-committete Ã„nderungen):"
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                GIT_DIFF=$(git diff 2>/dev/null || git diff HEAD 2>/dev/null || echo "Keine Ã„nderungen gefunden")
                if [[ -n "$GIT_DIFF" ]]; then
                    echo "$GIT_DIFF"
                else
                    echo "Keine ungesicherten Ã„nderungen gefunden."
                fi
                echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                echo ""
            fi

            # Build continue context for prompt
            CONTINUE_CONTEXT="
## CONTINUE MODE

Du arbeitest weiter an einer vorherigen Session die unterbrochen wurde.

**Letzter Eintrag aus progress.txt:**
$LAST_ENTRY

**WICHTIG:**
- Du musst weiter an dem zuletzt gewÃ¤hlten Item arbeiten (siehe oben)
- Der Git Diff zeigt bereits durchgefÃ¼hrte aber nicht-committete Ã„nderungen
- Analysiere den Diff um zu verstehen was bereits gemacht wurde
- Setze die Arbeit fort, fange nicht von vorne an!

**Git Diff der nicht-committeten Ã„nderungen:**
\`\`\`diff
$GIT_DIFF
\`\`\`
"
        else
            echo "âš ï¸  Keine EintrÃ¤ge in progress.txt gefunden. Starte normalen Modus..."
            CONTINUE_MODE=""
        fi
    else
        echo "âš ï¸  progress.txt nicht gefunden. Starte normalen Modus..."
        CONTINUE_MODE=""
    fi

    echo ""
    echo "Starte in 3 Sekunden... (Ctrl+C zum Abbrechen)"
    sleep 3
    # clear
fi

# Feature-branch detection: Check if we're on a feature branch with in-progress work
BRANCH_RESUME_TASK=""
if [[ -n "$CURRENT_BRANCH" && "$CURRENT_BRANCH" != "main" && "$CURRENT_BRANCH" != "master" ]]; then
    echo ""
    echo "ğŸŒ¿ Feature-Branch erkannt: $CURRENT_BRANCH"

    # Check progress.txt for in-progress work (entries with START but no DONE)
    if [[ -f "$PROGRESS_FILE" ]]; then
        # Find items that have START but no corresponding DONE
        BRANCH_RESUME_TASK=$(python3 -c "
import re, sys
started = {}
done = set()
with open('$PROGRESS_FILE') as f:
    for line in f:
        m = re.search(r'\] ([\w-]+):', line)
        if m:
            item_id = m.group(1)
            if '(START)' in line:
                started[item_id] = line.strip()
            if '[DONE' in line or '[RESOLVED]' in line:
                done.add(item_id)
# Find items started but not done
unfinished = [k for k in started if k not in done]
if unfinished:
    print(unfinished[-1])  # Most recent unfinished
else:
    print('')
" 2>/dev/null || echo "")

        if [[ -n "$BRANCH_RESUME_TASK" ]]; then
            echo "   âš ï¸  Unerledigte Arbeit gefunden: $BRANCH_RESUME_TASK"
            echo "   â†’ Selector wird angewiesen, diesen Task zu priorisieren."
        fi
    fi
fi

for ((i=1; i<=MAX_ITERATIONS; i++)); do
    # Show branch info on first iteration
    if [[ -n "$CURRENT_BRANCH" && "$CURRENT_BRANCH" != "main" && "$CURRENT_BRANCH" != "master" && $i -eq 1 ]]; then
        echo "ğŸŒ¿ Branch: $CURRENT_BRANCH"
    fi

    # Load perceptions
    PERCEPTIONS=""
    if [[ -f "$PERCEPTIONS_FILE" ]]; then
        PERCEPTIONS=$(cat "$PERCEPTIONS_FILE")
    fi

    # Build the full prompt
            # OpenCode: read file contents and embed in prompt (like claude)
            # OpenCode may not support -f flag as expected, so we read files directly

            # Get next bug if in bugfix mode
            BUG_INFO=""
            if [[ "$BUGFIX_MODE" == "true" ]]; then
                BUG_INFO=$(get_next_bug "$TASK_FILE")
                if [[ "$BUG_INFO" == "NONE" ]]; then
                    echo ""
                    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                    echo "â•‘  âœ… ALLE BUGS BEHOBEN! Keine offenen Bugs.  â•‘"
                    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    exit 0
                elif [[ "$BUG_INFO" == ERROR* ]]; then
                    echo "âŒ FEHLER beim Lesen der Bugs: $BUG_INFO"
                    exit 1
                else
                    # Parse bug info: id|title|priority|description
                    BUG_ID=$(echo "$BUG_INFO" | cut -d'|' -f1)
                    BUG_TITLE=$(echo "$BUG_INFO" | cut -d'|' -f2)
                    BUG_PRIORITY=$(echo "$BUG_INFO" | cut -d'|' -f3)
                    BUG_DESC=$(echo "$BUG_INFO" | cut -d'|' -f4-)
                fi
            fi

            # GH-Issues Mode: Two-step agent approach
            GH_ITEM_ID=""
            GH_ITEM_ISSUE_NUM=""
            GH_ITEM_DESC=""
            GH_ITEM_DETAILS=""
            USE_AGENT_MODE=""

            if [[ "$HAS_GH_ISSUES" == "true" && -n "$SELECTED_AGENT" ]]; then
                # Check if there are open items left (quick Python check)
                OPEN_COUNT=$(python3 -c "
import json, sys
try:
    with open('$TASK_FILE') as f:
        data = json.load(f)
    items = [i for i in data.get('items', []) if i.get('gh_issue_number') and not i.get('passes', False)]
    print(len(items))
except:
    print('0')
" 2>/dev/null || echo "0")

                if [[ "$OPEN_COUNT" == "0" ]]; then
                    echo ""
                    echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                    echo "â•‘  âœ… ALLE GH-ISSUES ERLEDIGT! Keine offenen Items.        â•‘"
                    echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                    echo ""
                    exit 0
                fi

                # â”€â”€ FORCE_TASK: Skip selector if --task was given â”€â”€
                if [[ -n "$FORCE_TASK" ]]; then
                    echo ""
                    echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
                    echo "â”‚  ğŸ¯ --task: Ãœberspringe Selector, lade Task direkt...  â”‚"
                    echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
                    echo ""

                    # Load item from prd.json by ID (case-insensitive)
                    FORCE_RESULT=$(python3 -c "
import json, sys
try:
    with open('$TASK_FILE') as f:
        data = json.load(f)
    target = '$FORCE_TASK'.lower()
    for item in data.get('items', []):
        if item.get('id', '').lower() == target:
            print(item.get('id', ''))
            print(item.get('gh_issue_number', ''))
            print(item.get('description', ''))
            print(item.get('details', ''))
            sys.exit(0)
    print('NOT_FOUND')
except Exception as e:
    print('ERROR:' + str(e))
" 2>/dev/null || echo "ERROR")

                    FORCE_FIRST_LINE=$(echo "$FORCE_RESULT" | head -1)
                    if [[ "$FORCE_FIRST_LINE" == "NOT_FOUND" ]]; then
                        echo "âŒ FEHLER: Task '$FORCE_TASK' nicht in $TASK_FILE gefunden."
                        echo "   VerfÃ¼gbare IDs:"
                        python3 -c "
import json
with open('$TASK_FILE') as f:
    data = json.load(f)
for item in data.get('items', []):
    status = 'âœ…' if item.get('passes') else 'â¬š'
    print(f'   {status} {item.get(\"id\", \"?\")} â€” {item.get(\"description\", \"\")}')
" 2>/dev/null || true
                        exit 1
                    elif [[ "$FORCE_FIRST_LINE" == ERROR* ]]; then
                        echo "âŒ FEHLER beim Laden von $TASK_FILE: $FORCE_FIRST_LINE"
                        exit 1
                    fi

                    GH_ITEM_ID=$(echo "$FORCE_RESULT" | sed -n '1p')
                    GH_ITEM_ISSUE_NUM=$(echo "$FORCE_RESULT" | sed -n '2p')
                    GH_ITEM_DESC=$(echo "$FORCE_RESULT" | sed -n '3p')
                    GH_ITEM_DETAILS=$(echo "$FORCE_RESULT" | sed -n '4,$p')
                    USE_AGENT_MODE=true
                    FORCE_TASK=""  # Only force first iteration

                    echo "âœ… Forced Task: $GH_ITEM_ID (Issue #$GH_ITEM_ISSUE_NUM)"
                    echo "   $GH_ITEM_DESC"
                    echo ""
                else
                # â”€â”€ STEP 1: Selector-Agent wÃ¤hlt das nÃ¤chste Item â”€â”€
                echo ""
                echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
                echo "â”‚  ğŸ“‹ Schritt 1: Selector-Agent wÃ¤hlt nÃ¤chstes Issue...  â”‚"
                echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
                echo ""

                SELECTOR_AGENT="${SELECTOR_AGENT:-build}"
                SELECTOR_PROMPT="Lies die Dateien .ralphy/prd.json und .ralphy/progress.txt.

Analysiere alle offenen Items (passes: false, mit gh_issue_number).

## WICHTIG: progress.txt prÃ¼fen
Lies .ralphy/progress.txt und prÃ¼fe ob es Items gibt, die einen (START)-Eintrag haben aber KEINEN [DONE]- oder [RESOLVED]-Eintrag. Diese Items wurden angefangen aber nicht abgeschlossen â€” sie haben **hÃ¶chste PrioritÃ¤t** und MÃœSSEN zuerst gewÃ¤hlt werden!

Deine Aufgabe ist es, das *strategisch wichtigste* nÃ¤chste Item auszuwÃ¤hlen.

Priorisiere in dieser Reihenfolge:
1. **Unerledigte Arbeit**: Items mit START aber ohne DONE/RESOLVED in progress.txt â€” diese ZUERST!
2. **Blocker-Status**: WÃ¤hle NUR Items, deren Dependencies (\`dependencies\`) bereits erledigt sind (\`passes: true\`).
3. **PrioritÃ¤t**: Critical > High > Medium > Low.
4. **Logische Architektur**: Backend vor Frontend, Core vor UI, Infrastruktur vor Features.
5. **Machbarkeit**: PrÃ¼fe kurz im Code (via Tools), ob die Voraussetzungen geschaffen sind.

Vermeide strikt:
- Einfach das erste Item der Liste zu nehmen (prÃ¼fe die ganze Liste!).
- Items zu wÃ¤hlen, die von noch offenen Items abhÃ¤ngen.
- Items, die bereits in progress.txt als erledigt markiert sind (Check gegen prd.json).

Antworte NUR in diesem exakten Format (eine Zeile, nichts anderes):
SELECTED|<item-id>|<gh_issue_number>|<description>

Beispiel:
SELECTED|GH-042|42|Login-Button reagiert nicht auf Klick

Wenn kein offenes Item gefunden wurde, antworte:
SELECTED|NONE|0|Keine offenen Items"

                # Append user message to selector prompt if set
                if [[ -n "$USER_MESSAGE" ]]; then
                    SELECTOR_PROMPT="${SELECTOR_PROMPT}

## ZusÃ¤tzliche Anweisung vom User:
${USER_MESSAGE}"
                fi

                # If on feature branch with unfinished work, instruct selector to prioritize it
                if [[ -n "$BRANCH_RESUME_TASK" ]]; then
                    SELECTOR_PROMPT="${SELECTOR_PROMPT}

## WICHTIG: Feature-Branch mit unerledigter Arbeit
Wir sind auf Branch '$CURRENT_BRANCH'. Laut progress.txt wurde an Item '$BRANCH_RESUME_TASK' bereits gearbeitet (START-Eintrag vorhanden, aber kein DONE).

**Du MUSST dieses Item auswÃ¤hlen**, damit die Arbeit abgeschlossen wird.
WÃ¤hle ein anderes Item NUR wenn '$BRANCH_RESUME_TASK' bereits als passes:true in prd.json markiert ist."

                    BRANCH_RESUME_TASK=""  # Only force on first iteration
                fi

                # Run selector agent
                OC_SELECTOR_CMD="${OPENCODE_FULL_PATH:-opencode}"
                SELECTOR_PROMPT_FILE=$(mktemp)
                echo "$SELECTOR_PROMPT" > "$SELECTOR_PROMPT_FILE"
                SELECTOR_OUTPUT=""

                if command -v expect >/dev/null 2>&1; then
                    SELECTOR_OUTPUT=$(expect << SELECTOR_EOF 2>/dev/null
set timeout 120
set prompt_content [read [open "$SELECTOR_PROMPT_FILE" r]]
spawn $OC_SELECTOR_CMD run --agent $SELECTOR_AGENT -m $MODEL \$prompt_content
expect {
    -re "Permission required.*Allow once" {
        send "\\r"
        exp_continue
    }
    -re "â¯|\\? " {
        send "\\r"
        exp_continue
    }
    eof {
        catch wait result
    }
}
SELECTOR_EOF
                    ) || true
                else
                    SELECTOR_OUTPUT=$($OC_SELECTOR_CMD run --agent "$SELECTOR_AGENT" -m "$MODEL" "$(cat "$SELECTOR_PROMPT_FILE")" 2>/dev/null || echo "")
                fi
                rm -f "$SELECTOR_PROMPT_FILE" 2>/dev/null || true

                # Parse selector output - look for SELECTED|... line
                SELECTED_LINE=$(echo "$SELECTOR_OUTPUT" | grep -oP 'SELECTED\|[^|]+\|[^|]+\|.+' | head -1 || echo "")

                if [[ -n "$SELECTED_LINE" ]]; then
                    GH_ITEM_ID=$(echo "$SELECTED_LINE" | cut -d'|' -f2)
                    GH_ITEM_ISSUE_NUM=$(echo "$SELECTED_LINE" | cut -d'|' -f3)
                    GH_ITEM_DESC=$(echo "$SELECTED_LINE" | cut -d'|' -f4-)

                    if [[ "$GH_ITEM_ID" == "NONE" ]]; then
                        echo "âœ… Selector-Agent: Keine offenen Items mehr."
                        exit 0
                    fi

                    # Fetch full details from prd.json for this item
                    GH_ITEM_DETAILS=$(python3 -c "
import json, sys
try:
    with open('$TASK_FILE') as f:
        data = json.load(f)
    for item in data.get('items', []):
        if item.get('id') == '$GH_ITEM_ID':
            print(item.get('details', ''))
            sys.exit(0)
    print('')
except:
    print('')
" 2>/dev/null || echo "")

                    USE_AGENT_MODE=true
                    echo "âœ… Selector-Agent hat gewÃ¤hlt: $GH_ITEM_ID (Issue #$GH_ITEM_ISSUE_NUM)"
                    echo "   $GH_ITEM_DESC"
                    echo ""
                else
                    echo "âš ï¸  Selector-Agent konnte kein Item auswÃ¤hlen."
                    echo "   Ausgabe: $(echo "$SELECTOR_OUTPUT" | tail -3)"
                    echo "   Fallback auf normalen Modus..."
                fi
                fi  # end of FORCE_TASK else
            fi

            if [[ "$USE_AGENT_MODE" == "true" ]]; then
                # â”€â”€ STEP 2: PrimÃ¤r-Agent bearbeitet das Issue â”€â”€
                echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
                echo "â”‚  ğŸ”§ Schritt 2: $SELECTED_AGENT bearbeitet Issue #$GH_ITEM_ISSUE_NUM  â”‚"
                echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
                echo ""

                # Build prompt for the primary agent (same style as RALPHY_PROMPT)
                FULL_PROMPT="Du bist ein erfahrener Software-Entwickler der systematisch GitHub Issues bearbeitet.

## Dein aktueller Task

**GitHub Issue #${GH_ITEM_ISSUE_NUM}** (${GH_ITEM_ID}): ${GH_ITEM_DESC}

${GH_ITEM_DETAILS}

## Iterationsablauf

1. **Sofort in progress.txt dokumentieren!**
   - Schreibe SOFORT in .ralphy/progress.txt:
   - Format: \`[YYYY-MM-DD HH:MM:SS] ${GH_ITEM_ID}: ${GH_ITEM_DESC} (START)\`
   - Hole Timestamp vom Terminal: \`date '+%Y-%m-%d %H:%M:%S'\`

2. **Codebase erkunden**: Verstehe die existierende Architektur bevor du Code schreibst.
   - Schaue dir Ã¤hnliche bereits implementierte Features an
   - Folge den bestehenden Patterns und Konventionen

3. **Implementieren**: Schreibe sauberen, getesteten Code.
   - Halte dich an Best Practices der Sprache/Framework

4. **Feedback Loops ausfÃ¼hren**:
   - FÃ¼hre Tests und Linter aus
   - Fahre NICHT fort wenn einer dieser Schritte fehlschlÃ¤gt. Behebe zuerst den Fehler.

5. **Fortschritt dokumentieren**:
   - Aktualisiere .ralphy/progress.txt mit dem was du getan hast
   - Setze \`passes: true\` fÃ¼r Item ${GH_ITEM_ID} in .ralphy/prd.json

6. **Git Commit erstellen**:
   - \`git add -A && git commit -m \"fix(${GH_ITEM_ID}): Kurze Beschreibung\"\`

## Wichtige Regeln

- ARBEITE NUR AN DIESEM EINEN ISSUE pro Durchlauf
- Commit nur wenn ALLE Feedback Loops bestehen
- Wenn du blockiert bist, dokumentiere das Problem in progress.txt
- QualitÃ¤t vor Geschwindigkeit
- Folge den bestehenden Code-Patterns

## Kontext-Dateien

### prd.json:
$(cat "$TASK_FILE" 2>/dev/null || echo "Nicht gefunden")

### progress.txt:
$(cat "$PROGRESS_FILE" 2>/dev/null || echo "Noch leer")

### CLAUDE.md:
$(cat "$CLAUDE_FILE" 2>/dev/null || echo "Nicht gefunden")

## Stop Condition

Wenn du mit Issue #${GH_ITEM_ISSUE_NUM} fertig bist, gib aus: <promise>COMPLETE</promise>"

                # Append user message to implementer prompt if set
                if [[ -n "$USER_MESSAGE" ]]; then
                    FULL_PROMPT="${FULL_PROMPT}

## ZusÃ¤tzliche Anweisung vom User:
${USER_MESSAGE}"
                fi
            else
                FULL_PROMPT="${RALPHY_PROMPT_BASE}

## Dateien:

### ${TASK_NAME}.json:
$(cat "$TASK_FILE" 2>/dev/null || echo "âš ï¸  Datei nicht gefunden: $TASK_FILE")

### progress.txt:
$(cat "$PROGRESS_FILE" 2>/dev/null || echo "âš ï¸  Datei nicht gefunden: $PROGRESS_FILE")

### CLAUDE.md:
$(cat "$CLAUDE_FILE" 2>/dev/null || echo "âš ï¸  Datei nicht gefunden: $CLAUDE_FILE")

---
${PERCEPTIONS}
${CONTINUE_CONTEXT}"

                # Append user message to normal prompt if set
                if [[ -n "$USER_MESSAGE" ]]; then
                    FULL_PROMPT="${FULL_PROMPT}

## ZusÃ¤tzliche Anweisung vom User:
${USER_MESSAGE}"
                fi
            fi
            # Execute: opencode run (with agent or model) "prompt"
            # Start progress indicator in background with fixed header at top
            # Uses scroll region to keep header separate from log output
            TOOL_STATUS_FILE=$(mktemp)
            TOOL_COUNT_FILE=$(mktemp)
            echo "0 0 0 0" > "$TOOL_COUNT_FILE"  # read edit bash other

            # Record iteration start time
            ITERATION_START_TIME=$(date +%s)
            export ITERATION_START_TIME

            # Export file paths for subshells
            export TOOL_STATUS_FILE TOOL_COUNT_FILE

            # Get terminal dimensions
            TERM_LINES=$(tput lines 2>/dev/null || echo 24)
            TERM_COLS=$(tput cols 2>/dev/null || echo 80)
            HEADER_LINES=5  # Number of lines reserved for header

            # Format seconds to human readable time
            format_time() {
                local seconds="$1"
                local hours=$((seconds / 3600))
                local minutes=$(((seconds % 3600) / 60))
                local secs=$((seconds % 60))

                if [[ $hours -gt 0 ]]; then
                    printf "%dh %dm %ds" "$hours" "$minutes" "$secs"
                elif [[ $minutes -gt 0 ]]; then
                    printf "%dm %ds" "$minutes" "$secs"
                else
                    printf "%ds" "$secs"
                fi
            }

            # Draw status bar at bottom of terminal
            draw_statusbar() {
                local elapsed="$1"
                local status="$2"
                local phase="$3"
                local reads="$4"
                local edits="$5"
                local bashes="$6"
                local others="$7"
                local total=$((reads + edits + bashes + others))
                local iter_time="$(format_time $elapsed)"
                local total_time="$(format_time $(($(date +%s) - GLOBAL_START_TIME)))"

                # Phase icon and text
                local phase_icon phase_text
                case "$phase" in
                    recherche)  phase_icon="ğŸ”"; phase_text="\033[1;33mRecherche\033[0m" ;;
                    implement)  phase_icon="âš™ï¸ "; phase_text="\033[1;32mImplementierung\033[0m" ;;
                    validate)   phase_icon="âœ…"; phase_text="\033[1;34mValidierung\033[0m" ;;
                    commit)     phase_icon="ğŸ“¦"; phase_text="\033[1;35mCommit\033[0m" ;;
                    *)          phase_icon="â³"; phase_text="\033[1mArbeitet...\033[0m" ;;
                esac

                # Calculate bottom lines (3 lines)
                local line1=$((TERM_LINES - 2))
                local line2=$((TERM_LINES - 1))
                local line3=$((TERM_LINES))

                printf "\033[s" >&2

                # Line 1: Iteration & Phase
                printf "\033[%d;1H\033[K\033[1;36mğŸ“ Iteration %d/%d\033[0m - %s %b" "$line1" "$i" "$MAX_ITERATIONS" "$phase_icon" "$phase_text" >&2

                # Line 2: Timers
                printf "\033[%d;1H\033[K\033[90mâ±ï¸  %-8s - ğŸ• Gesamt: %s\033[0m" "$line2" "$iter_time" "$total_time" >&2

                # Line 3: Tools
                printf "\033[%d;1H\033[K\033[90mğŸ“Š Tools: %-3d - ğŸ“– %-3d - âœï¸  %-3d - ğŸ’» %-3d - ğŸ”§ %-3d\033[0m" "$line3" "$total" "$reads" "$edits" "$bashes" "$others" >&2

                printf "\033[u" >&2
            }

            # Setup: Set scroll region for top of terminal, reserve bottom for status
            # STATUSBAR_LINES=3
            # printf "\033[1;$((TERM_LINES - STATUSBAR_LINES))r" >&2   # Set scroll region (top to bottom-3)
            # Don't reset cursor to top - let it continue from current position

            # Draw initial status bar
            # draw_statusbar 0 "Startet..." "init" 0 0 0 0

            echo "â”â”â” Iteration $i gestartet â”â”â”"

            # (
            #     sleep 1  # Wait 1s before first update
            #     counter=1
            #     current_status="Startet..."
            #     current_phase="init"
            #     while true; do
            #         # Read current status
            #         if [[ -f "$TOOL_STATUS_FILE" ]]; then
            #             read -r new_status new_phase < "$TOOL_STATUS_FILE" 2>/dev/null || true
            #             [[ -n "$new_status" ]] && current_status="$new_status"
            #             [[ -n "$new_phase" ]] && current_phase="$new_phase"
            #         fi
            #
            #         # Read tool counts
            #         reads=0 edits=0 bashes=0 others=0
            #         if [[ -f "$TOOL_COUNT_FILE" ]]; then
            #             read -r reads edits bashes others < "$TOOL_COUNT_FILE" 2>/dev/null || true
            #         fi
            #
            #         # Update status bar
            #         # draw_statusbar $((counter * 2)) "$current_status" "$current_phase" "${reads:-0}" "${edits:-0}" "${bashes:-0}" "${others:-0}"
            #
            #         sleep 2
            #         counter=$((counter + 1))
            #     done
            # ) &
            # PROGRESS_PID=$!
            # export PROGRESS_PID  # Make it available to trap handler

            # Execute and capture output, displaying it in real-time
            # Use a temp file and tee to both display and capture
            TEMP_OUTPUT=$(mktemp)

            # Build the actual command to execute
            if [[ "$USE_AGENT_MODE" == "true" ]]; then
                OC_RUN_CMD="$CMD run --agent $SELECTED_AGENT -m $MODEL"
            else
                OC_RUN_CMD="$CMD $CMD_ARGS"
            fi

            # Execute command with auto-confirmation of "Allow once" permissions
            # Simple approach: Use expect if available, otherwise just execute normally
            # User can still manually confirm if needed
            if command -v expect >/dev/null 2>&1; then
                # Use expect script to auto-confirm permissions and agent questions
                expect << EOF | while IFS= read -r line; do
set timeout -1
spawn bash -c "$OC_RUN_CMD \"$FULL_PROMPT\""
expect {
    -re "Permission required.*Allow once" {
        # Check if it's a Remove request outside project directory
        set line \$expect_out(buffer)
        if {[regexp -nocase {Remove|Delete} \$line] && ![string match "*$PROJECT_DIR*" \$line]} {
            send_user "âš ï¸  Ãœberspringe: Remove-Anfrage auÃŸerhalb des Projekts\\n"
            interact
            exp_continue
        }
        # Auto-confirm with Enter (Allow once is default)
        send "\\r"
        exp_continue
    }
    -re "â¯|\\? " {
        # Auto-confirm agent questions (qfixer tool-call "question")
        send "\\r"
        exp_continue
    }
    eof {
        catch wait result
        exit [lindex \$result 3]
    }
}
EOF
                    # Process line - update counts and status
                    # Strip ANSI color codes for matching
                    clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g')

                    # Check for tool calls (format: |  ToolName  args)
                    if [[ "$clean_line" =~ ^\|[[:space:]]+([A-Za-z_]+)[[:space:]]+(.*)$ ]]; then
                        TOOL_TYPE="${BASH_REMATCH[1]}"
                        TOOL_ARG="${BASH_REMATCH[2]}"

                        # Read current counts
                        read -r t_reads t_edits t_bashes t_others < "$TOOL_COUNT_FILE" 2>/dev/null || { t_reads=0; t_edits=0; t_bashes=0; t_others=0; }

                        case "$TOOL_TYPE" in
                            Read|read_file|Glob|Grep|grep|glob)
                                t_reads=$((t_reads + 1))
                                echo "$TOOL_ARG recherche" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Edit|edit_file|search_replace)
                                t_edits=$((t_edits + 1))
                                echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Write|write)
                                t_edits=$((t_edits + 1))
                                echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Bash|bash|shell)
                                t_bashes=$((t_bashes + 1))
                                # Detect phase from bash command
                                if echo "$TOOL_ARG" | grep -qiE "git commit|git add"; then
                                    echo "$TOOL_ARG commit" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                elif echo "$TOOL_ARG" | grep -qiE "flutter test|flutter analyze|pub get"; then
                                    echo "$TOOL_ARG validate" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                else
                                    echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                fi
                                ;;
                            webfetch|web_search|WebSearch|WebFetch)
                                t_others=$((t_others + 1))
                                echo "Web-Suche recherche" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Todo|TodoWrite|todo|discard|extract)
                                t_others=$((t_others + 1))
                                echo "Planung implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            *)
                                t_others=$((t_others + 1))
                                echo "$TOOL_TYPE implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                        esac

                        # Update counts
                        echo "$t_reads $t_edits $t_bashes $t_others" > "$TOOL_COUNT_FILE" 2>/dev/null || true
                    fi
                    # Truncate output line to 250 chars
                    if [[ ${#line} -gt 250 ]]; then
                        echo "${line:0:250}..."
                    else
                        echo "$line"
                    fi
                done | tee "$TEMP_OUTPUT" || true
            else
                # Fallback: Execute normally (user will need to manually confirm)
                $OC_RUN_CMD "$FULL_PROMPT" 2>&1 | while IFS= read -r line; do
                    # Process line - update counts and status
                    # Strip ANSI color codes for matching
                    clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*m//g')

                    # Check for tool calls (format: |  ToolName  args)
                    if [[ "$clean_line" =~ ^\|[[:space:]]+([A-Za-z_]+)[[:space:]]+(.*)$ ]]; then
                        TOOL_TYPE="${BASH_REMATCH[1]}"
                        TOOL_ARG="${BASH_REMATCH[2]}"

                        # Read current counts
                        read -r t_reads t_edits t_bashes t_others < "$TOOL_COUNT_FILE" 2>/dev/null || { t_reads=0; t_edits=0; t_bashes=0; t_others=0; }

                        case "$TOOL_TYPE" in
                            Read|read_file|Glob|Grep|grep|glob)
                                t_reads=$((t_reads + 1))
                                echo "$TOOL_ARG recherche" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Edit|edit_file|search_replace)
                                t_edits=$((t_edits + 1))
                                echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Write|write)
                                t_edits=$((t_edits + 1))
                                echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Bash|bash|shell)
                                t_bashes=$((t_bashes + 1))
                                # Detect phase from bash command
                                if echo "$TOOL_ARG" | grep -qiE "git commit|git add"; then
                                    echo "$TOOL_ARG commit" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                elif echo "$TOOL_ARG" | grep -qiE "flutter test|flutter analyze|pub get"; then
                                    echo "$TOOL_ARG validate" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                else
                                    echo "$TOOL_ARG implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                fi
                                ;;
                            webfetch|web_search|WebSearch|WebFetch)
                                t_others=$((t_others + 1))
                                echo "Web-Suche recherche" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            Todo|TodoWrite|todo|discard|extract)
                                t_others=$((t_others + 1))
                                echo "Planung implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                            *)
                                t_others=$((t_others + 1))
                                echo "$TOOL_TYPE implement" > "$TOOL_STATUS_FILE" 2>/dev/null || true
                                ;;
                        esac

                        # Update counts
                        echo "$t_reads $t_edits $t_bashes $t_others" > "$TOOL_COUNT_FILE" 2>/dev/null || true
                    fi
                    # Truncate output line to 250 chars
                    if [[ ${#line} -gt 250 ]]; then
                        echo "${line:0:250}..."
                    else
                        echo "$line"
                    fi
                done | tee "$TEMP_OUTPUT" || true
            fi
            EXIT_CODE=${PIPESTATUS[0]}
            result=$(cat "$TEMP_OUTPUT" 2>/dev/null || echo "")
            rm -f "$TEMP_OUTPUT"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Kill progress indicator and reset terminal
            if [[ -n "$PROGRESS_PID" ]]; then
                kill "$PROGRESS_PID" 2>/dev/null || true
                wait "$PROGRESS_PID" 2>/dev/null || true
            fi
            PROGRESS_PID=""

            # Read final counts for summary
            FINAL_READS=0 FINAL_EDITS=0 FINAL_BASHES=0 FINAL_OTHERS=0
            if [[ -f "$TOOL_COUNT_FILE" ]]; then
                read -r FINAL_READS FINAL_EDITS FINAL_BASHES FINAL_OTHERS < "$TOOL_COUNT_FILE" 2>/dev/null || true
            fi
            FINAL_TOTAL=$((FINAL_READS + FINAL_EDITS + FINAL_BASHES + FINAL_OTHERS))

            rm -f "$TOOL_STATUS_FILE" "$TOOL_COUNT_FILE" 2>/dev/null || true

            # Clear status bar but keep scroll region active
            # for ((line=TERM_LINES-STATUSBAR_LINES+1; line<=TERM_LINES; line++)); do
            #     printf "\033[s\033[%d;1H\033[K\033[u" "$line" >&2
            # done

            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… OpenCode beendet (Exit Code: $EXIT_CODE)"
            echo "ğŸ“Š Tool-Statistik: $FINAL_TOTAL total â”‚ ğŸ“– Read: $FINAL_READS â”‚ âœï¸ Edit: $FINAL_EDITS â”‚ ğŸ’» Bash: $FINAL_BASHES â”‚ ğŸ”§ Other: $FINAL_OTHERS"

            # Get token stats from opencode stats
            STATS_OUTPUT=$(opencode stats --project "" --days 1 2>/dev/null || echo "")
            if [[ -n "$STATS_OUTPUT" ]]; then
                AVG_TOKENS=$(echo "$STATS_OUTPUT" | grep -oP 'Avg Tokens/Session\s+\K[\d.]+[KM]?' || echo "?")
                TOTAL_COST=$(echo "$STATS_OUTPUT" | grep -oP 'Total Cost\s+\K\$[\d.]+' || echo "$0.00")
                INPUT_TOKENS=$(echo "$STATS_OUTPUT" | grep -oP 'â”‚Input\s+\K[\d.]+[KM]?' || echo "?")
                OUTPUT_TOKENS=$(echo "$STATS_OUTPUT" | grep -oP 'â”‚Output\s+\K[\d.]+[KM]?' || echo "?")
                echo "ğŸ’° Tokens: ~$AVG_TOKENS avg â”‚ In: $INPUT_TOKENS â”‚ Out: $OUTPUT_TOKENS â”‚ Kosten: $TOTAL_COST"
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Debug: Show result length and first/last lines if result is not empty
            if [[ -z "$result" ]]; then
                echo "âš ï¸  Warnung: OpenCode hat keine Ausgabe zurÃ¼ckgegeben (leere Antwort)"
            else
                RESULT_LENGTH=${#result}
                echo "ğŸ“Š Ausgabe-LÃ¤nge: $RESULT_LENGTH Zeichen"
                echo "ğŸ“„ Erste 200 Zeichen:"
                echo "${result:0:200}..."
                echo ""
                if [[ $RESULT_LENGTH -gt 400 ]]; then
                    echo "ğŸ“„ Letzte 200 Zeichen:"
                    echo "...${result: -200}"
                fi
            fi
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

    # Check for errors in result (but don't treat empty result as error - might be normal)
    if [[ -n "$result" ]] && ([[ "$result" == *"Error:"* ]] || [[ "$result" == *"error"* ]] || [[ "$result" == *"FEHLER"* ]] || [[ "$result" == *"File not found"* ]]); then
        echo ""
        echo "âš ï¸  Warnung: Fehler in der Ausgabe erkannt. Weiter mit nÃ¤chster Iteration..."
        echo ""
    elif [[ -z "$result" ]]; then
        echo ""
        echo "âš ï¸  Warnung: Keine Ausgabe von OpenCode erhalten (mÃ¶glicherweise Timeout oder Fehler)."
        echo "   Weiter mit nÃ¤chster Iteration..."
        echo ""
    fi

    # Check for completion (only if result contains the promise tag and no errors)
    if [[ "$result" == *"<promise>COMPLETE</promise>"* ]] && [[ "$result" != *"Error:"* ]] && [[ "$result" != *"FEHLER"* ]]; then
        # If in bugfix mode, update bug status
        if [[ "$BUGFIX_MODE" == "true" ]] && [[ -n "$BUG_ID" ]]; then
            echo ""
            echo "ğŸ”„ Aktualisiere Bug-Status..."
            RESOLVE_RESULT=$(resolve_bug "$TASK_FILE" "$BUG_ID")
            if [[ "$RESOLVE_RESULT" == "OK" ]]; then
                echo "âœ… Bug $BUG_ID als resolved markiert!"
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] $BUG_ID: $BUG_TITLE - [RESOLVED]" >> "$PROGRESS_FILE"
            else
                echo "âš ï¸  Fehler beim Aktualisieren des Bug-Status: $RESOLVE_RESULT"
            fi
        fi

        # If GH-Issue mode, mark item as passes: true and continue loop
        if [[ "$USE_AGENT_MODE" == "true" && -n "$GH_ITEM_ID" ]]; then
            echo ""
            echo "ğŸ”„ Markiere $GH_ITEM_ID als erledigt..."
            python3 -c "
import json

try:
    with open('$TASK_FILE', 'r') as f:
        data = json.load(f)

    for item in data.get('items', []):
        if item.get('id') == '$GH_ITEM_ID':
            item['passes'] = True
            break

    with open('$TASK_FILE', 'w') as f:
        json.dump(data, f, indent=2)

    print('OK')
except Exception as e:
    print(f'ERROR: {e}')
" 2>/dev/null
            echo "âœ… $GH_ITEM_ID (Issue #$GH_ITEM_ISSUE_NUM) als erledigt markiert!"
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] $GH_ITEM_ID: $GH_ITEM_DESC - [DONE via $SELECTED_AGENT]" >> "$PROGRESS_FILE"

            # Check if all GH-issue items are done
            ALL_GH_DONE=$(python3 -c "
import json
try:
    with open('$TASK_FILE') as f:
        data = json.load(f)
    gh_items = [i for i in data.get('items', []) if i.get('gh_issue_number')]
    all_done = all(i.get('passes', False) for i in gh_items)
    print('true' if all_done else 'false')
except:
    print('false')
" 2>/dev/null || echo "false")

            if [[ "$ALL_GH_DONE" == "true" ]]; then
                # printf "\033[r" >&2
                echo ""
                echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
                echo "â•‘  âœ… ALLE GH-ISSUES ERLEDIGT!                              â•‘"
                echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                echo ""
                echo "Provider: $PROVIDER_DISPLAY (Agent: $SELECTED_AGENT)"
                echo "Iterationen: $i von $MAX_ITERATIONS"
                echo ""
                echo "PrÃ¼fe .ralphy/progress.txt fÃ¼r Details."
                exit 0
            fi

            # Continue to next iteration (next GH-issue item)
            echo ""
            echo "â³ Pause vor nÃ¤chstem Issue ($PAUSE_SECONDS Sekunden)..."
            sleep $PAUSE_SECONDS
            continue
        fi

        # Reset scroll region before final output
        # printf "\033[r" >&2
        echo ""
        echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
        if [[ "$BUGFIX_MODE" == "true" ]]; then
            echo "â•‘  âœ… BUG FIXING COMPLETE! Bug behoben.                        â•‘"
        else
            echo "â•‘  âœ… PRD COMPLETE! Alle kritischen Features implementiert.  â•‘"
        fi
        echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Provider: $PROVIDER_DISPLAY"
        echo "Iterationen: $i von $MAX_ITERATIONS"
        echo ""
        echo "PrÃ¼fe .ralphy/progress.txt fÃ¼r Details."
        exit 0
    fi

    echo ""
    echo "â³ Pause vor nÃ¤chster Iteration ($PAUSE_SECONDS Sekunden)..."
    sleep $PAUSE_SECONDS
done

# Reset scroll region after loop ends
# printf "\033[r" >&2

echo ""
echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
echo "â•‘  âš ï¸  Max Iterationen erreicht ($MAX_ITERATIONS)                      â•‘"
echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""
echo "Provider: $PROVIDER_DISPLAY"
echo "PrÃ¼fe .ralphy/progress.txt fÃ¼r aktuellen Stand."
